// helpers.go

package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	gt "github.com/meinside/gemini-things-go"
	tg "github.com/meinside/telegram-bot-go"
	"github.com/meinside/version-go"

	"google.golang.org/api/googleapi"
	"google.golang.org/genai"
)

// get usable message from given update
func messageFromUpdate(update tg.Update) (message *tg.Message) {
	if update.HasMessage() && update.Message.HasText() {
		message = update.Message
	} else if update.HasMessage() && update.Message.HasDocument() {
		message = update.Message
	} else if update.HasEditedMessage() && update.EditedMessage.HasText() {
		message = update.EditedMessage
	}

	if message == nil {
		logInfo("no usable message from update.")
	}

	return message
}

// save prompt and its result to logs database
func savePromptAndResult(db *Database, chatID, userID int64, username string, prompt string, promptTokens int, resultTokens int, resultSuccessful bool) {
	if db != nil {
		if err := db.SavePrompt(Prompt{
			ChatID:   chatID,
			UserID:   userID,
			Username: username,
			Text:     prompt,
			Tokens:   promptTokens,
			Result: ParsedItem{
				Successful: resultSuccessful,
				Tokens:     resultTokens,
			},
		}); err != nil {
			log.Printf("failed to save prompt & result to database: %s", err)
		}
	}
}

// generate a help message with version info
func helpMessage(conf config) string {
	return fmt.Sprintf(msgHelp, conf.GoogleGenerativeModel, version.Build(version.OS|version.Architecture|version.Revision), githubPageURL)
}

// type for parsed items
type parsedItem struct {
	Message   string
	When      time.Time
	Generated bool // if this item was generated by the bot (due to vague request)
}

// function declarations for genai model
func fnDeclarations(conf config) []*genai.FunctionDeclaration {
	return []*genai.FunctionDeclaration{
		{
			Name:        fnNameInferDatetime,
			Description: fnDescriptionInferDatetime,
			Parameters: &genai.Schema{
				Type: genai.TypeObject,
				Properties: map[string]*genai.Schema{
					fnArgNameInferredDatetime: {
						Type:        genai.TypeString,
						Description: fmt.Sprintf(fnArgDescriptionInferredDatetime, conf.DefaultHour),
						Nullable:    ptr(false),
					},
					fnArgNameMessageToSend: {
						Type:        genai.TypeString,
						Description: fnArgDescriptionMessageToSend,
						Nullable:    ptr(false),
					},
				},
				Required: []string{
					fnArgNameInferredDatetime,
					fnArgNameMessageToSend,
				},
				Nullable: ptr(false),
			},
		},
	}
}

// handle function call
func handleFnCall(conf config, fn genai.FunctionCall) (result []parsedItem, err error) {
	logDebug(conf, "[verbose] handling function call: %s", prettify(fn))

	result = []parsedItem{}

	if fn.Name == fnNameInferDatetime {
		datetime := val[string](fn.Args, fnArgNameInferredDatetime)
		message := val[string](fn.Args, fnArgNameMessageToSend)

		if message != "" && datetime != "" {
			if t, e := time.ParseInLocation(datetimeFormat, datetime, _location); e == nil {
				result = append(result, parsedItem{
					Message:   message,
					When:      t,
					Generated: false,
				})
			} else {
				err = fmt.Errorf("failed to parse '%s' (%s) in function call: %s", fnArgNameInferredDatetime, e, prettify(fn.Args))
			}
		} else {
			err = fmt.Errorf("invalid `%s` and/or `%s` in function call: %s", fnArgNameInferredDatetime, fnArgNameMessageToSend, prettify(fn.Args))
		}
	} else {
		err = fmt.Errorf("no function declaration for name: %s", fn.Name)
	}

	if err != nil {
		logDebug(conf, "[verbose] there was an error with returned function call: %s", err)
	}

	return result, err
}

// get value for given `key` from `m`, return the zero value if it has no such key
func val[T any](m map[string]any, key string) T {
	var r T

	if v, exists := m[key]; exists {
		if v, ok := v.(T); ok {
			r = v
		}
	}

	return r
}

// prettify given value in indented JSON format (for debugging purporse)
func prettify(v any) string {
	if bytes, err := json.MarshalIndent(v, "", "  "); err == nil {
		return string(bytes)
	}

	return fmt.Sprintf("%+v", v)
}

// parse given string, generate items from the parsed ones, and return them
func parse(ctx context.Context, conf config, db *Database, gtc *gt.Client, message tg.Message, text string) (result []parsedItem, errs []error) {
	result = []parsedItem{}
	errs = []error{}

	chatID := message.Chat.ID
	userID := message.From.ID
	username := userName(message.From)

	// options for generation
	opts := &gt.GenerationOptions{
		// set function declarations
		Tools: []*genai.Tool{
			{
				FunctionDeclarations: fnDeclarations(conf),
			},
		},
		// function call config
		ToolConfig: &genai.ToolConfig{
			// https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/function-calling
			FunctionCallingConfig: &genai.FunctionCallingConfig{
				Mode: genai.FunctionCallingConfigModeAny,
				AllowedFunctionNames: []string{
					fnNameInferDatetime,
				},
			},
		},
	}

	// generate text
	var numTokensInput, numTokensOutput int32
	if contents, err := gtc.PromptsToContents(ctx, []gt.Prompt{
		gt.PromptFromText(text),
	},
		nil,
	); err == nil {
		if generated, err := gtc.Generate(
			ctx,
			contents,
			opts,
		); err == nil {
			logDebug(conf, "[verbose] generated: %s", prettify(generated))

			// token counts
			if generated.UsageMetadata != nil {
				if generated.UsageMetadata.PromptTokenCount != 0 {
					numTokensInput = generated.UsageMetadata.PromptTokenCount
				}
				if generated.UsageMetadata.CandidatesTokenCount != 0 {
					numTokensOutput = generated.UsageMetadata.CandidatesTokenCount
				}
			}

			if len(generated.Candidates) <= 0 {
				logError(db, "there was no returned candidate")
			} else {
				for _, candidate := range generated.Candidates {
					content := candidate.Content

					if len(content.Parts) > 0 {
						for _, part := range content.Parts {
							if part.FunctionCall != nil { // if it is a function call,
								if handled, err := handleFnCall(conf, *part.FunctionCall); err == nil {
									// append result
									result = append(result, handled...)
								} else {
									errs = append(errs, err)

									logError(db, "failed to handle function call: %s", err)
								}
								break
							}
						}
					} else {
						errs = append(errs, fmt.Errorf("no part in content"))

						logError(db, "there was no part in the returned content")
					}
				}

				if len(result) <= 0 {
					errs = append(errs, fmt.Errorf("no function call in parts"))

					logError(db, "there was no usable function call in the returned parts")
				}
			}
		} else {
			errs = append(errs, fmt.Errorf("failed to generate text: %s", errorString(err)))

			// log failure
			savePromptAndResult(db, chatID, userID, username, text, int(numTokensInput), int(numTokensOutput), false)

			logError(db, "failed to generate text: %s", errorString(err))
		}
	} else {
		errs = append(errs, fmt.Errorf("failed to convert prompts/files to contents: %s", errorString(err)))

		logError(db, "failed to convert prompts/files to contents: %s", errorString(err))
	}

	// log success
	if len(errs) <= 0 {
		savePromptAndResult(db, chatID, userID, username, text, int(numTokensInput), int(numTokensOutput), true)
	}

	return result, errs
}

// filter parsed items to be all valid
func filterParsed(conf config, parsed []parsedItem) (filtered []parsedItem) {
	// add some generated items for convenience
	generated := []parsedItem{}
	for _, p := range parsed {
		// save it as it is,
		generated = append(generated, p)

		// and add generated ones,
		when := p.When.In(_location)
		hour, minute := when.Hour(), when.Minute()
		if hour == 0 && minute == 0 {
			// default hour
			generated = append(generated, parsedItem{
				Message:   p.Message,
				When:      p.When.In(_location).Add(time.Hour * time.Duration(conf.DefaultHour)),
				Generated: true,
			})
		} else if hour < 12 {
			// add 12 hours if it is AM
			generated = append(generated, parsedItem{
				Message:   p.Message,
				When:      p.When.In(_location).Add(time.Hour * 12),
				Generated: true,
			})
		}
	}

	// remove already-passed or duplicated ones
	filtered = []parsedItem{}
	duplicated := map[string]bool{}
	now := time.Now()
	for _, p := range generated {
		when := p.When.In(_location)

		// remove duplicated ones,
		dup := when.Format(datetimeFormat)
		if _, exists := duplicated[dup]; exists {
			continue
		} else {
			duplicated[dup] = true // mark as duplicated,

			// and remove already-passed ones
			if when.After(now) {
				filtered = append(filtered, p)
			}
		}
	}

	return filtered
}

// generate user's name
func userName(user *tg.User) string {
	if user.Username != nil {
		return fmt.Sprintf("@%s (%s)", *user.Username, user.FirstName)
	} else {
		return user.FirstName
	}
}

// generate user's name from update
func userNameFromUpdate(update tg.Update) string {
	if user := update.GetFrom(); user != nil {
		return userName(user)
	}

	logInfo("there was no `from` in `update`")

	return "unknown"
}

var (
	_stdout = log.New(os.Stdout, "", log.LstdFlags)
	_stderr = log.New(os.Stderr, "", log.LstdFlags)
)

// log info message
func logInfo(format string, a ...any) {
	_stdout.Printf(format, a...)
}

// log debug message (printed to stdout only when `IsVerbose` is true)
func logDebug(conf config, format string, a ...any) {
	if conf.Verbose {
		_stdout.Printf(format, a...)
	}
}

// log error message
func logError(db *Database, format string, a ...any) {
	if db != nil {
		db.LogError(format, a...)
	}

	_stderr.Printf(format, a...)
}

// log error message and exit(1)
func logErrorAndDie(db *Database, format string, a ...any) {
	if db != nil {
		db.LogError(format, a...)
	}

	_stderr.Fatalf(format, a...)
}

// default reply markup
func defaultReplyMarkup() tg.ReplyKeyboardMarkup {
	return tg.NewReplyKeyboardMarkup( // show keyboards
		[][]tg.KeyboardButton{
			tg.NewKeyboardButtons(cmdListReminders, cmdCancel, cmdStats),
			tg.NewKeyboardButtons(cmdPrivacy, cmdHelp),
		}).
		SetResizeKeyboard(true)
}

// generate inline keyboard buttons for multiple datetimes
func datetimeButtonsForCallbackQuery(items []parsedItem, chatID int64, messageID int64) [][]tg.InlineKeyboardButton {
	// datetime buttons
	keys := make(map[string]string)

	var title, generated string
	for _, item := range items {
		if item.Generated {
			generated = " *"
		} else {
			generated = ""
		}
		title = fmt.Sprintf("%s%s", datetimeToStr(item.When), generated)
		keys[title] = fmt.Sprintf("%s %d/%d/%s", cmdLoad, chatID, messageID, datetimeToStr(item.When))
	}
	buttons := tg.NewInlineKeyboardButtonsAsRowsWithCallbackData(keys)

	// add cancel button
	buttons = append(buttons, []tg.InlineKeyboardButton{
		tg.NewInlineKeyboardButton(msgCancel).
			SetCallbackData(cmdCancel),
	})

	return buttons
}

// format given time to string
func datetimeToStr(t time.Time) string {
	return t.In(_location).Format(datetimeFormat)
}

// convert error to string
func errorString(err error) (error string) {
	var gerr *googleapi.Error
	if errors.As(err, &gerr) {
		return fmt.Sprintf("googleapi error: %s", gerr.Body)
	} else {
		return err.Error()
	}
}

// return a pointer to given value
func ptr[T any](t T) *T {
	return &t
}

// shorten returns a string trimmed to fit in given `maxLength`
func shorten(str string, maxLength int) string {
	bs := []byte(str)
	if len(bs) > maxLength {
		str = strings.ToValidUTF8(string(bs[:maxLength-3]), "") + "..."
	}
	return str
}
